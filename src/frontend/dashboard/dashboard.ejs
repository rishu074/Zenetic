<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zenetic - Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        body {
            background-color: #0f172a;
            color: #e2e8f0;
            min-height: 100vh;
        }

        .main-content {
            padding: 6rem 2rem 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .page-title {
            font-size: 2rem;
            font-weight: 600;
            color: #f8fafc;
        }

        .graph-container {
            background-color: #1e293b;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            height: 450px;
            display: flex;
            flex-direction: column;
        }

        .distribution-container {
            background-color: #1e293b;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            height: 450px;
            display: flex;
            flex-direction: column;
        }

        .distribution-header {
            margin-bottom: 1.5rem;
        }

        .distribution-title {
            font-size: 1.25rem;
            font-weight: 500;
            color: #f8fafc;
        }

        .graph-header {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .graph-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .legend-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.5rem 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .graph-title {
            font-size: 1.25rem;
            font-weight: 500;
            color: #f8fafc;
        }

        .time-range-selector {
            display: flex;
            gap: 1rem;
        }

        .time-range-btn {
            padding: 0.5rem 1rem;
            background-color: #334155;
            border: none;
            border-radius: 0.5rem;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.2s;
        }

        .time-range-btn.active {
            background-color: #3b82f6;
            color: #ffffff;
        }

        .time-range-btn:hover:not(.active) {
            background-color: #475569;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .section-header {
            font-size: 1.5rem;
            font-weight: 600;
            color: #f8fafc;
            margin: 3rem 0 2rem;
        }

        .section-subheader {
            font-size: 1.25rem;
            font-weight: 500;
            color: #f8fafc;
            margin-bottom: 1rem;
        }

        .observations-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .tag-stats-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 2rem;
            width: 100%;
        }

        .tag-chart-container {
            background-color: #1e293b;
            border-radius: 1rem;
            padding: 1.5rem;
            height: 400px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            width: 100%;
        }

        .tag-chart-header {
            grid-column: 1 / -1;
            margin-bottom: 1rem;
            width: 100%;
        }

        .stat-card {
            background-color: #1e293b;
            border-radius: 1rem;
            padding: 1.5rem;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 600;
            color: #3b82f6;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .graph-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
        }

        .graph-nav-btn {
            padding: 0.5rem 1rem;
            background-color: #334155;
            border: none;
            border-radius: 0.5rem;
            color: #94a3b8;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .graph-nav-btn:hover:not(:disabled) {
            background-color: #475569;
        }

        .graph-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .current-period {
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .chart-wrapper {
            flex: 1;
            position: relative;
            min-height: 0;
            min-width: 0;
            width: 100%;
            height: 100%;
        }

        .date-input {
            padding: 0.75rem 1rem;
            background-color: #334155;
            border: none;
            border-radius: 0.5rem;
            color: #94a3b8;
        }

        .date-input::-webkit-calendar-picker-indicator {
            filter: invert(0.6);
            cursor: pointer;
        }

        /* New styles for Today's Tasks section */
        .tasks-overview {
            background-color: #1e293b;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .tasks-overview:hover {
            transform: translateY(-2px);
        }

        .tasks-overview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .tasks-overview-title {
            font-size: 1.25rem;
            font-weight: 500;
            color: #f8fafc;
        }

        .tasks-count {
            background-color: #3b82f6;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .tasks-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .task-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background-color: #334155;
            border-radius: 0.75rem;
            transition: all 0.2s;
        }

        .task-item:hover {
            background-color: #475569;
            transform: translateY(-2px);
        }

        .task-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .task-title {
            color: #f8fafc;
            font-size: 1rem;
            font-weight: 500;
        }

        .task-meta {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .task-type {
            background-color: #3b82f6;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: capitalize;
        }

        .task-schedule {
            color: #94a3b8;
            font-size: 0.875rem;
        }

        .task-actions {
            display: flex;
            gap: 0.5rem;
        }

        .complete-btn {
            padding: 0.5rem 1rem;
            background-color: #22c55e;
            border: none;
            border-radius: 0.5rem;
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .complete-btn:hover {
            background-color: #16a34a;
        }

        /* Task Performance Graph styles */
        .task-performance {
            background-color: #1e293b;
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 2rem;
            height: 400px;
            display: flex;
            flex-direction: column;
        }

        .performance-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .performance-title {
            font-size: 1.25rem;
            font-weight: 500;
            color: #f8fafc;
        }

        .performance-legend {
            display: flex;
            gap: 1.5rem;
        }

        .performance-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-expected {
            background-color: #3b82f6;
        }

        .legend-completed {
            background-color: #22c55e;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 5rem 1rem 1rem;
            }

            .page-header {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }

            .time-range-selector {
                flex-wrap: wrap;
                width: 100%;
            }

            .time-range-btn {
                flex: 1;
                min-width: 120px;
                text-align: center;
            }

            .tag-stats-container {
                grid-template-columns: 1fr;
            }

            .graph-container {
                height: 350px;
            }

            .distribution-container {
                height: 350px;
            }

            .tag-chart-container {
                height: 350px;
            }

            .graph-controls {
                flex-wrap: wrap;
                gap: 1rem;
                justify-content: center;
            }

            .current-period {
                order: -1;
                width: 100%;
                text-align: center;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .observations-stats {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .main-content {
                padding: 4rem 0.75rem 1rem;
            }

            .page-title {
                font-size: 1.5rem;
            }

            .section-header {
                font-size: 1.25rem;
            }

            .time-range-btn {
                padding: 0.5rem;
                font-size: 0.875rem;
            }

            .stat-value {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <%- include('navbar') %>
    
    <main class="main-content">
        <div class="page-header">
            <h1 class="page-title">Dashboard</h1>
        </div>

        <!-- Today's Tasks Section -->
        <div class="tasks-overview" onclick="window.location.href='/dashboard/todo'">
            <div class="tasks-overview-header">
                <h2 class="tasks-overview-title">Today's Tasks</h2>
                <span class="tasks-count" id="tasksCount">0 tasks</span>
            </div>
            <div class="tasks-list" id="tasksList">
                <div class="loading">Loading tasks...</div>
            </div>
        </div>

        <!-- Task Performance Graph -->
        <div class="task-performance">
            <div class="performance-header">
                <h2 class="performance-title">Task Performance</h2>
                <div class="performance-legend">
                    <div class="performance-legend-item">
                        <div class="legend-color legend-expected"></div>
                        <span>Expected</span>
                    </div>
                    <div class="performance-legend-item">
                        <div class="legend-color legend-completed"></div>
                        <span>Completed</span>
                    </div>
                </div>
            </div>
            <div class="graph-controls">
                <button class="graph-nav-btn" id="taskPrevPeriod">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                    Previous
                </button>
                <span class="current-period" id="taskCurrentPeriod"></span>
                <button class="graph-nav-btn" id="taskNextPeriod">
                    Next
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"/>
                    </svg>
                </button>
            </div>
            <div class="chart-wrapper">
                <canvas id="taskPerformanceChart"></canvas>
            </div>
        </div>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="totalJournals">-</div>
                <div class="stat-label">Total Journals</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="thisWeekJournals">-</div>
                <div class="stat-label">Journals Last 7 Days</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="thisMonthJournals">-</div>
                <div class="stat-label">Journals This Month</div>
            </div>
        </div>

        <h2 class="section-header">Journal Activity</h2>

        <div class="graph-container">
            <div class="graph-header">
                <div class="time-range-selector">
                    <button class="time-range-btn active" data-range="monthly">Monthly</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="journalChart"></canvas>
            </div>
            <div class="graph-controls">
                <button class="graph-nav-btn" id="prevPeriod">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                    Previous
                </button>
                <span class="current-period" id="currentPeriod"></span>
                <button class="graph-nav-btn" id="nextPeriod">
                    Next
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"/>
                    </svg>
                </button>
            </div>
        </div>

        <h2 class="section-header">Journal Types</h2>

        <div class="distribution-container">
            <div class="chart-wrapper">
                <canvas id="distributionChart"></canvas>
            </div>
        </div>

        <h2 class="section-header">Observations</h2>

        <div class="observations-stats">
            <div class="stat-card">
                <div class="stat-value" id="totalObservations">-</div>
                <div class="stat-label">Total Observations</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="thisWeekObservations">-</div>
                <div class="stat-label">Observations Last 7 Days</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="thisMonthObservations">-</div>
                <div class="stat-label">Observations This Month</div>
            </div>
        </div>

        <div class="graph-container">
            <div class="graph-header">
                <div class="time-range-selector">
                    <button class="time-range-btn active" data-range="monthly" data-target="observations">Monthly</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="observationsChart"></canvas>
            </div>
            <div class="graph-controls">
                <button class="graph-nav-btn" id="observationsPrevPeriod">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                    Previous
                </button>
                <span class="current-period" id="observationsCurrentPeriod"></span>
                <button class="graph-nav-btn" id="observationsNextPeriod">
                    Next
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"/>
                    </svg>
                </button>
            </div>
        </div>

        <h2 class="section-subheader">Most Common Patterns</h2>
        <div class="time-range-selector" style="margin-bottom: 1rem;">
            <button class="time-range-btn active" data-range="week" data-target="observation-tags">Last 7 Days</button>
            <button class="time-range-btn" data-range="15days" data-target="observation-tags">Last 15 Days</button>
            <button class="time-range-btn" data-range="30days" data-target="observation-tags">Last 30 Days</button>
        </div>
        <div class="tag-stats-container">
            <div class="tag-chart-container">
                <h3 class="graph-title">Most Common Feelings</h3>
                <div class="chart-wrapper">
                    <canvas id="feelingsChart"></canvas>
                </div>
            </div>
            <div class="tag-chart-container">
                <h3 class="graph-title">Most Common Urges</h3>
                <div class="chart-wrapper">
                    <canvas id="urgesChart"></canvas>
                </div>
            </div>
        </div>

        <h2 class="section-header">Drifts</h2>

        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="totalDrifts">-</div>
                <div class="stat-label">Total Drifts</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="thisWeekDrifts">-</div>
                <div class="stat-label">Drifts Last 7 Days</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="thisMonthDrifts">-</div>
                <div class="stat-label">Drifts This Month</div>
            </div>
        </div>

        <div class="graph-container">
            <div class="graph-header">
                <div class="time-range-selector">
                    <button class="time-range-btn active" data-range="monthly" data-target="drifts">Monthly</button>
                </div>
            </div>
            <div class="chart-wrapper">
                <canvas id="driftsChart"></canvas>
            </div>
            <div class="graph-controls">
                <button class="graph-nav-btn" id="driftsPrevPeriod">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                    Previous
                </button>
                <span class="current-period" id="driftsCurrentPeriod"></span>
                <button class="graph-nav-btn" id="driftsNextPeriod">
                    Next
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18l6-6-6-6"/>
                    </svg>
                </button>
            </div>
        </div>

        <h2 class="section-subheader">Most Common Patterns Leading to Drifts</h2>
        <div class="time-range-selector" style="margin-bottom: 1rem;">
            <button class="time-range-btn active" data-range="week" data-target="drift-tags">Last 7 Days</button>
            <button class="time-range-btn" data-range="15days" data-target="drift-tags">Last 15 Days</button>
            <button class="time-range-btn" data-range="30days" data-target="drift-tags">Last 30 Days</button>
        </div>
        <div class="tag-stats-container">
            <div class="tag-chart-container">
                <h3 class="graph-title">Feelings Leading to Drifts</h3>
                <div class="chart-wrapper">
                    <canvas id="driftFeelingsChart"></canvas>
                </div>
            </div>
            <div class="tag-chart-container">
                <h3 class="graph-title">Urges Leading to Drifts</h3>
                <div class="chart-wrapper">
                    <canvas id="driftUrgesChart"></canvas>
                </div>
            </div>
        </div>
    </main>

    <script>
        let journalChart = null;
        let distributionChart = null;
        let observationsChart = null;
        let feelingsChart = null;
        let urgesChart = null;
        let currentOffset = 0;
        let observationsOffset = 0;
        let allJournals = [];
        let allObservations = [];
        let currentRange = 'daily';
        let observationsRange = 'monthly';
        let currentTagRange = 'week';
        let customStartDate = null;
        let customEndDate = null;
        let performanceChart = null;
        let currentPage = 1;
        const DAYS_PER_PAGE = 7;

        // New variables for drift analytics
        let driftsChart = null;
        let driftFeelingsChart = null;
        let driftUrgesChart = null;
        let driftsOffset = 0;
        let allDrifts = [];
        let driftObservations = new Map();

        // Colors for different journal types
        const typeColors = {
            'normal': '#3b82f6',
            'New Learning': '#22c55e',
            'Health Awareness': '#eab308',
            'Valentine\'s Day': '#ec4899',
            'Birthday': '#a855f7',
            'Open Source Contribution': '#f97316',
            'New Year Celebration': '#06b6d4',
            'Productivity Hack': '#64748b',
            'New Recipe': '#14b8a6',
            'Coding Streak': '#8b5cf6',
            'Workout Milestone': '#ef4444'
        };

        // Fetch journals data and update stats
        async function fetchJournalStats() {
            try {
                let allJournalsTemp = [];
                let currentPage = 1;
                let hasMore = true;

                // Fetch all journals using pagination
                while (hasMore) {
                    const response = await fetch(`/api/journals?filters={}&limit=200&page=${currentPage}&projection={"content": false}`);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.message || 'Failed to fetch journals');
                    }

                    const journals = data.data.journals;
                    allJournalsTemp = [...allJournalsTemp, ...journals];
                    
                    // Check if we have more pages
                    hasMore = journals.length === 200 && allJournalsTemp.length < data.data.total;
                    currentPage++;

                    // Update loading state in UI
                    document.getElementById('totalJournals').textContent = `${allJournalsTemp.length}/${data.data.total}`;
                }

                allJournals = allJournalsTemp;
                const total = allJournals.length;

                // Update total journals stat
                document.getElementById('totalJournals').textContent = total;

                // Calculate last 7 days and this month's journals
                const now = new Date();
                const last7Days = new Date(now);
                last7Days.setDate(now.getDate() - 6);
                last7Days.setHours(0, 0, 0, 0);

                const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

                const last7DaysCount = allJournals.filter(journal => 
                    new Date(journal.date) >= last7Days
                ).length;

                const thisMonthCount = allJournals.filter(journal => 
                    new Date(journal.date) >= startOfMonth
                ).length;

                document.getElementById('thisWeekJournals').textContent = last7DaysCount;
                document.getElementById('thisMonthJournals').textContent = thisMonthCount;

                return allJournals;
            } catch (error) {
                console.error('Error fetching journal stats:', error);
                return [];
            }
        }

        // Fetch observations data and update stats
        async function fetchObservationStats() {
            try {
                let allObservationsTemp = [];
                let currentPage = 1;
                let hasMore = true;

                // Fetch all observations using pagination
                while (hasMore) {
                    const response = await fetch(`/api/observations?filters={}&limit=200&page=${currentPage}&projection={"sequences": false}`);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.message || 'Failed to fetch observations');
                    }

                    const observations = data.data.observations;
                    allObservationsTemp = [...allObservationsTemp, ...observations];
                    
                    // Check if we have more pages
                    hasMore = observations.length === 200 && allObservationsTemp.length < data.data.total;
                    currentPage++;

                    // Update loading state in UI
                    document.getElementById('totalObservations').textContent = `${allObservationsTemp.length}/${data.data.total}`;
                }

                allObservations = allObservationsTemp;
                const total = allObservations.length;

                // Update total observations stat
                document.getElementById('totalObservations').textContent = total;

                // Calculate last 7 days and this month's observations
                const now = new Date();
                const last7Days = new Date(now);
                last7Days.setDate(now.getDate() - 6);
                last7Days.setHours(0, 0, 0, 0);

                const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

                const last7DaysCount = allObservations.filter(observation => 
                    new Date(observation.date) >= last7Days
                ).length;

                const thisMonthCount = allObservations.filter(observation => 
                    new Date(observation.date) >= startOfMonth
                ).length;

                document.getElementById('thisWeekObservations').textContent = last7DaysCount;
                document.getElementById('thisMonthObservations').textContent = thisMonthCount;

                // Update tag charts
                updateTagCharts(allObservations, 'week');

                return allObservations;
            } catch (error) {
                console.error('Error fetching observations:', error);
                return [];
            }
        }

        // Process journals data for different time ranges
        function processJournalData(journals, range) {
            const now = new Date();
            const data = new Map();
            
            if (range === 'daily') {
                // Show 7 days per page
                for (let i = 6; i >= 0; i--) {
                    const date = new Date(now);
                    date.setDate(date.getDate() - i - (currentOffset * 7));
                    date.setHours(0, 0, 0, 0);
                    data.set(date.toISOString().split('T')[0], 0);
                }

                journals.forEach(journal => {
                    const date = new Date(journal.date).toISOString().split('T')[0];
                    if (data.has(date)) {
                        data.set(date, data.get(date) + 1);
                    }
                });
            } else if (range === 'weekly') {
                // Show 4 weeks per page
                for (let i = 3; i >= 0; i--) {
                    const date = new Date(now);
                    date.setDate(date.getDate() - (i * 7) - (currentOffset * 28));
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    data.set(weekStart.toISOString().split('T')[0], 0);
                }

                journals.forEach(journal => {
                    const date = new Date(journal.date);
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    const key = weekStart.toISOString().split('T')[0];
                    if (data.has(key)) {
                        data.set(key, data.get(key) + 1);
                    }
                });
            } else if (range === 'monthly') {
                // Show 6 months per page
                for (let i = 5; i >= 0; i--) {
                    const date = new Date(now.getFullYear(), now.getMonth() - i - (currentOffset * 6), 1);
                    data.set(date.toISOString().split('T')[0], 0);
                }

                journals.forEach(journal => {
                    const date = new Date(journal.date);
                    const monthStart = new Date(date.getFullYear(), date.getMonth(), 1);
                    const key = monthStart.toISOString().split('T')[0];
                    if (data.has(key)) {
                        data.set(key, data.get(key) + 1);
                    }
                });
            }

            // Update period display
            updatePeriodDisplay(Array.from(data.keys())[0], Array.from(data.keys())[data.size - 1], range);

            // Update navigation buttons
            updateNavigationButtons(journals, range);

            return {
                labels: Array.from(data.keys()).map(date => {
                    if (range === 'daily') {
                        return new Date(date).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                    } else if (range === 'weekly') {
                        const d = new Date(date);
                        return `Week of ${d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
                    } else {
                        return new Date(date).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                    }
                }),
                datasets: [{
                    label: 'Number of Journals',
                    data: Array.from(data.values()),
                    backgroundColor: '#3b82f6',
                    borderColor: '#2563eb',
                    borderWidth: 1,
                    borderRadius: 4
                }]
            };
        }

        // Process distribution data
        function processDistributionData(journals) {
            const typeCount = new Map();
            
            journals.forEach(journal => {
                const type = journal.special || 'normal';
                typeCount.set(type, (typeCount.get(type) || 0) + 1);
            });

            // Sort by count in descending order
            const sortedTypes = Array.from(typeCount.entries())
                .sort((a, b) => b[1] - a[1]);

            return {
                labels: sortedTypes.map(([type]) => type.charAt(0).toUpperCase() + type.slice(1)),
                datasets: [{
                    data: sortedTypes.map(([, count]) => count),
                    backgroundColor: sortedTypes.map(([type]) => typeColors[type] || '#6b7280'),
                    borderWidth: 0,
                    borderRadius: 4
                }]
            };
        }

        // Process observations data for different time ranges
        function processObservationsData(observations, range) {
            const now = new Date();
            const data = new Map();
            
            // Show 6 months per page
            for (let i = 5; i >= 0; i--) {
                const date = new Date(now.getFullYear(), now.getMonth() - i - (observationsOffset * 6), 1);
                date.setHours(0, 0, 0, 0);
                data.set(date.toISOString().split('T')[0], 0);
            }

            observations.forEach(observation => {
                const obsDate = new Date(observation.date);
                const monthStart = new Date(obsDate.getFullYear(), obsDate.getMonth(), 1);
                monthStart.setHours(0, 0, 0, 0);
                const key = monthStart.toISOString().split('T')[0];
                if (data.has(key)) {
                    data.set(key, data.get(key) + 1);
                }
            });

            // Update period display
            updateObservationsPeriodDisplay(Array.from(data.keys())[0], Array.from(data.keys())[data.size - 1], range);

            // Update navigation buttons
            updateObservationsNavigationButtons(observations, range);

            const sortedDates = Array.from(data.keys()).sort();
            
            return {
                labels: sortedDates.map(date => {
                    const d = new Date(date);
                    return d.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                }),
                datasets: [{
                    label: 'Number of Observations',
                    data: sortedDates.map(date => data.get(date)),
                    backgroundColor: '#22c55e',
                    borderColor: '#22c55e',
                    borderWidth: 2,
                    tension: 0.4,
                    fill: false
                }]
            };
        }

        function updatePeriodDisplay(startDate, endDate, range) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            let displayText;

            if (range === 'daily') {
                displayText = `${start.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
            } else if (range === 'weekly') {
                displayText = `${start.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
            } else {
                displayText = `${start.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
            }

            document.getElementById('currentPeriod').textContent = displayText;
        }

        function updateNavigationButtons(journals, range) {
            const prevBtn = document.getElementById('prevPeriod');
            const nextBtn = document.getElementById('nextPeriod');

            // Disable next button if we're at the current period
            nextBtn.disabled = currentOffset === 0;

            // Disable prev button if we don't have any older data
            const oldestDate = new Date(Math.min(...journals.map(j => new Date(j.date))));
            const now = new Date();
            let periodSize;

            if (range === 'daily') {
                periodSize = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
            } else if (range === 'weekly') {
                periodSize = 28 * 24 * 60 * 60 * 1000; // 28 days in milliseconds
            } else {
                periodSize = 180 * 24 * 60 * 60 * 1000; // ~6 months in milliseconds
            }

            const currentPeriodStart = new Date(now - (currentOffset + 1) * periodSize);
            prevBtn.disabled = oldestDate > currentPeriodStart;
        }

        function updateObservationsPeriodDisplay(startDate, endDate, range) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            let displayText;

            if (range === 'daily') {
                displayText = `${start.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
            } else if (range === 'weekly') {
                displayText = `${start.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
            } else {
                displayText = `${start.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
            }

            document.getElementById('observationsCurrentPeriod').textContent = displayText;
        }

        function updateObservationsNavigationButtons(observations, range) {
            const prevBtn = document.getElementById('observationsPrevPeriod');
            const nextBtn = document.getElementById('observationsNextPeriod');

            // Disable next button if we're at the current period
            nextBtn.disabled = observationsOffset === 0;

            // Disable prev button if we don't have any older data
            const oldestDate = new Date(Math.min(...observations.map(o => new Date(o.date))));
            const now = new Date();
            let periodSize;

            if (range === 'daily') {
                periodSize = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
            } else if (range === 'weekly') {
                periodSize = 28 * 24 * 60 * 60 * 1000; // 28 days in milliseconds
            } else {
                periodSize = 180 * 24 * 60 * 60 * 1000; // ~6 months in milliseconds
            }

            const currentPeriodStart = new Date(now - (observationsOffset + 1) * periodSize);
            prevBtn.disabled = oldestDate > currentPeriodStart;
        }

        // Update chart with new data
        function updateChart(data, range) {
            const ctx = document.getElementById('journalChart').getContext('2d');
            
            if (journalChart) {
                journalChart.destroy();
            }

            journalChart = new Chart(ctx, {
                type: 'bar',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: (tooltipItems) => {
                                    const date = new Date(data.labels[tooltipItems[0].dataIndex]);
                                    return date.toLocaleDateString('en-US', { 
                                        weekday: 'long', 
                                        year: 'numeric', 
                                        month: 'long', 
                                        day: 'numeric' 
                                    });
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                color: '#94a3b8',
                                padding: 10,
                                precision: 0
                            },
                            grid: {
                                color: '#334155',
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        },
                        x: {
                            stacked: true,
                            ticks: {
                                color: '#94a3b8',
                                padding: 5,
                                maxRotation: 0
                            },
                            grid: {
                                display: false
                            },
                            border: {
                                display: false
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 10,
                            left: 10,
                            right: 10
                        }
                    }
                }
            });
        }

        // Update distribution chart
        function updateDistributionChart(journals) {
            const ctx = document.getElementById('distributionChart').getContext('2d');
            
            if (distributionChart) {
                distributionChart.destroy();
            }

            const data = processDistributionData(journals);

            distributionChart = new Chart(ctx, {
                type: 'bar',
                data: data,
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const label = context.label || '';
                                    const value = context.raw || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${value} journals (${percentage}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                display: false
                            },
                            border: {
                                display: false
                            }
                        },
                        x: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 50,
                                color: '#94a3b8',
                                precision: 0
                            },
                            grid: {
                                color: '#334155',
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 10,
                            left: 10,
                            right: 10
                        }
                    }
                }
            });
        }

        // Update observations chart
        function updateObservationsChart(data) {
            const ctx = document.getElementById('observationsChart').getContext('2d');
            
            if (observationsChart) {
                observationsChart.destroy();
            }

            observationsChart = new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: (tooltipItems) => {
                                    const date = new Date(data.labels[tooltipItems[0].dataIndex]);
                                    return date.toLocaleDateString('en-US', { 
                                        weekday: 'long', 
                                        year: 'numeric', 
                                        month: 'long', 
                                        day: 'numeric' 
                                    });
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1,
                                color: '#94a3b8',
                                padding: 10,
                                precision: 0
                            },
                            grid: {
                                color: '#334155',
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        },
                        x: {
                            ticks: {
                                color: '#94a3b8',
                                padding: 5,
                                maxRotation: 0
                            },
                            grid: {
                                display: false
                            },
                            border: {
                                display: false
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 20,
                            bottom: 10,
                            left: 10,
                            right: 10
                        }
                    }
                }
            });
        }

        // Process tag data for feelings and urges with date range
        function processTagData(observations, type, range) {
            const now = new Date();
            let startDate;
            
            if (range === 'week') {
                startDate = new Date(now);
                startDate.setDate(now.getDate() - 6);
                startDate.setHours(0, 0, 0, 0);
            } else if (range === '15days') {
                startDate = new Date(now);
                startDate.setDate(now.getDate() - 14);
                startDate.setHours(0, 0, 0, 0);
            } else if (range === '30days') {
                startDate = new Date(now);
                startDate.setDate(now.getDate() - 29);
                startDate.setHours(0, 0, 0, 0);
            }

            const filteredObservations = observations.filter(observation => {
                const obsDate = new Date(observation.date);
                return obsDate >= startDate && obsDate <= now;
            });

            const tagCount = new Map();
            
            filteredObservations.forEach(observation => {
                const tags = observation[type] || [];
                tags.forEach(tag => {
                    tagCount.set(tag, (tagCount.get(tag) || 0) + 1);
                });
            });

            // Sort by count in descending order and take top 10
            const sortedTags = Array.from(tagCount.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            return {
                labels: sortedTags.map(([tag]) => tag.charAt(0).toUpperCase() + tag.slice(1)),
                datasets: [{
                    data: sortedTags.map(([, count]) => count),
                    backgroundColor: '#3b82f6',
                    borderWidth: 0,
                    borderRadius: 4
                }]
            };
        }

        // Update tag charts with date range
        function updateTagCharts(observations, range) {
            const feelingsCtx = document.getElementById('feelingsChart').getContext('2d');
            const urgesCtx = document.getElementById('urgesChart').getContext('2d');
            
            if (feelingsChart) {
                feelingsChart.destroy();
                feelingsChart = null;
            }
            if (urgesChart) {
                urgesChart.destroy();
                urgesChart = null;
            }

            const data = processTagData(observations, 'feelings', range);
            const urgesData = processTagData(observations, 'urges', range);

            feelingsChart = new Chart(feelingsCtx, {
                type: 'bar',
                data: data,
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                display: false,
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        },
                        x: {
                            beginAtZero: true,
                            ticks: {
                                color: '#94a3b8',
                                precision: 0
                            },
                            grid: {
                                color: '#334155',
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 30
                        }
                    },
                    barPercentage: 0.95,
                    categoryPercentage: 0.95,
                    barThickness: 25
                }
            });

            urgesChart = new Chart(urgesCtx, {
                type: 'bar',
                data: urgesData,
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                display: false,
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        },
                        x: {
                            beginAtZero: true,
                            ticks: {
                                color: '#94a3b8',
                                precision: 0
                            },
                            grid: {
                                color: '#334155',
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 30
                        }
                    },
                    barPercentage: 0.95,
                    categoryPercentage: 0.95,
                    barThickness: 25
                }
            });
        }

        // Fetch drifts data and update stats
        async function fetchDriftStats() {
            try {
                let allDriftsTemp = [];
                let currentPage = 1;
                let hasMore = true;

                // Fetch all drifts using pagination
                while (hasMore) {
                    const response = await fetch(`/api/drifts?filters={}&limit=200&page=${currentPage}&projection={}`);
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.message || 'Failed to fetch drifts');
                    }

                    const drifts = data.data.drifts;
                    allDriftsTemp = [...allDriftsTemp, ...drifts];
                    
                    // Check if we have more pages
                    hasMore = drifts.length === 200 && allDriftsTemp.length < data.data.total;
                    currentPage++;

                    // Update loading state in UI
                    document.getElementById('totalDrifts').textContent = `${allDriftsTemp.length}/${data.data.total}`;
                }

                allDrifts = allDriftsTemp;
                const total = allDrifts.length;

                // Update total drifts stat
                document.getElementById('totalDrifts').textContent = total;

                // Calculate last 7 days and this month's drifts
                const now = new Date();
                const last7Days = new Date(now);
                last7Days.setDate(now.getDate() - 6);
                last7Days.setHours(0, 0, 0, 0);

                const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

                const last7DaysCount = allDrifts.filter(drift => 
                    new Date(drift.date) >= last7Days
                ).length;

                const thisMonthCount = allDrifts.filter(drift => 
                    new Date(drift.date) >= startOfMonth
                ).length;

                document.getElementById('thisWeekDrifts').textContent = last7DaysCount;
                document.getElementById('thisMonthDrifts').textContent = thisMonthCount;

                // Collect all unique observation IDs from all drifts
                const allObservationIds = [...new Set(allDrifts.flatMap(drift => drift.observations))];

                // Batch fetch all observations in chunks of 100
                const chunkSize = 100;
                const observationChunks = [];
                for (let i = 0; i < allObservationIds.length; i += chunkSize) {
                    const chunk = allObservationIds.slice(i, i + chunkSize);
                    observationChunks.push(chunk);
                }

                // Fetch observations in parallel chunks
                const observationsResults = await Promise.all(
                    observationChunks.map(chunk => fetchObservations(chunk))
                );

                // Flatten results and create a map for quick lookup
                const observationsMap = new Map();
                observationsResults.flat().forEach(obs => {
                    observationsMap.set(obs._id, obs);
                });

                // Store observations in the driftObservations map
                allDrifts.forEach(drift => {
                    driftObservations.set(drift._id, 
                        drift.observations
                            .map(obsId => observationsMap.get(obsId))
                            .filter(Boolean) // Remove any undefined entries
                    );
                });

                return allDrifts;
            } catch (error) {
                console.error('Error fetching drift stats:', error);
                return [];
            }
        }

        // Optimized fetchObservations function
        async function fetchObservations(ids) {
            try {
                const filters = { _id: { $in: ids } };
                const response = await fetch(`/api/observations?filters=${JSON.stringify(filters)}&limit=${ids.length}&page=1`);
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.message || 'Failed to fetch observations');
                }

                return data.data.observations;
            } catch (error) {
                console.error('Error fetching observations:', error);
                return [];
            }
        }

        // Process drifts data for different time ranges
        function processDriftsData(drifts, range) {
            const now = new Date();
            const data = new Map();
            
            // Show 6 months per page
            for (let i = 5; i >= 0; i--) {
                const date = new Date(now.getFullYear(), now.getMonth() - i - (driftsOffset * 6), 1);
                date.setHours(0, 0, 0, 0);
                data.set(date.toISOString().split('T')[0], 0);
            }

            drifts.forEach(drift => {
                const driftDate = new Date(drift.date);
                const monthStart = new Date(driftDate.getFullYear(), driftDate.getMonth(), 1);
                monthStart.setHours(0, 0, 0, 0);
                const key = monthStart.toISOString().split('T')[0];
                if (data.has(key)) {
                    data.set(key, data.get(key) + 1);
                }
            });

            // Update period display
            updateDriftsPeriodDisplay(Array.from(data.keys())[0], Array.from(data.keys())[data.size - 1], range);

            // Update navigation buttons
            updateDriftsNavigationButtons(drifts, range);

            const sortedDates = Array.from(data.keys()).sort();
            
            return {
                labels: sortedDates.map(date => {
                    return new Date(date).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                }),
                datasets: [{
                    label: 'Number of Drifts',
                    data: sortedDates.map(date => data.get(date)),
                    backgroundColor: '#ef4444',
                    borderColor: '#ef4444',
                    borderWidth: 2,
                    tension: 0.4,
                    fill: false
                }]
            };
        }

        // Process drift patterns data
        function processDriftPatternsData(range = 'week') {
            const now = new Date();
            let startDate;
            
            if (range === 'week') {
                startDate = new Date(now);
                startDate.setDate(now.getDate() - 6);
                startDate.setHours(0, 0, 0, 0);
            } else if (range === '15days') {
                startDate = new Date(now);
                startDate.setDate(now.getDate() - 14);
                startDate.setHours(0, 0, 0, 0);
            } else if (range === '30days') {
                startDate = new Date(now);
                startDate.setDate(now.getDate() - 29);
                startDate.setHours(0, 0, 0, 0);
            }

            const feelingsCount = new Map();
            const urgesCount = new Map();
            
            // Count feelings and urges from drift observations within the time range
            for (const drift of allDrifts) {
                const driftDate = new Date(drift.date);
                if (driftDate >= startDate && driftDate <= now) {
                    const observations = driftObservations.get(drift._id) || [];
                    observations.forEach(observation => {
                        observation.feelings.forEach(feeling => {
                            feelingsCount.set(feeling, (feelingsCount.get(feeling) || 0) + 1);
                        });
                        observation.urges.forEach(urge => {
                            urgesCount.set(urge, (urgesCount.get(urge) || 0) + 1);
                        });
                    });
                }
            }

            // Sort by count in descending order and take top 10
            const sortedFeelings = Array.from(feelingsCount.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            const sortedUrges = Array.from(urgesCount.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            return {
                feelings: {
                    labels: sortedFeelings.map(([feeling]) => feeling.charAt(0).toUpperCase() + feeling.slice(1)),
                    datasets: [{
                        data: sortedFeelings.map(([, count]) => count),
                        backgroundColor: '#ef4444',
                        borderWidth: 0,
                        borderRadius: 4
                    }]
                },
                urges: {
                    labels: sortedUrges.map(([urge]) => urge.charAt(0).toUpperCase() + urge.slice(1)),
                    datasets: [{
                        data: sortedUrges.map(([, count]) => count),
                        backgroundColor: '#ef4444',
                        borderWidth: 0,
                        borderRadius: 4
                    }]
                }
            };
        }

        // Update drifts chart
        function updateDriftsChart(data) {
            const ctx = document.getElementById('driftsChart').getContext('2d');
            
            if (driftsChart) {
                driftsChart.destroy();
            }

            driftsChart = new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: (tooltipItems) => {
                                    const date = new Date(data.labels[tooltipItems[0].dataIndex]);
                                    return date.toLocaleDateString('en-US', { 
                                        year: 'numeric', 
                                        month: 'long'
                                    });
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                display: false
                            },
                            border: {
                                display: false
                            }
                        },
                        x: {
                            ticks: {
                                color: '#94a3b8'
                            },
                            grid: {
                                color: '#334155',
                                drawBorder: false
                            },
                            border: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Update drift patterns charts
        function updateDriftPatternsCharts(data) {
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            color: '#94a3b8'
                        },
                        grid: {
                            display: false
                        },
                        border: {
                            display: false
                        }
                    },
                    x: {
                        ticks: {
                            color: '#94a3b8'
                        },
                        grid: {
                            color: '#334155',
                            drawBorder: false
                        },
                        border: {
                            display: false
                        }
                    }
                }
            };

            // Update feelings chart
            const feelingsCtx = document.getElementById('driftFeelingsChart').getContext('2d');
            if (driftFeelingsChart) {
                driftFeelingsChart.destroy();
            }
            driftFeelingsChart = new Chart(feelingsCtx, {
                type: 'bar',
                data: data.feelings,
                options
            });

            // Update urges chart
            const urgesCtx = document.getElementById('driftUrgesChart').getContext('2d');
            if (driftUrgesChart) {
                driftUrgesChart.destroy();
            }
            driftUrgesChart = new Chart(urgesCtx, {
                type: 'bar',
                data: data.urges,
                options
            });
        }

        function updateDriftsPeriodDisplay(startDate, endDate, range) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            const displayText = `${start.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}`;
            document.getElementById('driftsCurrentPeriod').textContent = displayText;
        }

        function updateDriftsNavigationButtons(drifts, range) {
            const prevBtn = document.getElementById('driftsPrevPeriod');
            const nextBtn = document.getElementById('driftsNextPeriod');

            // Disable next button if we're at the current period
            nextBtn.disabled = driftsOffset === 0;

            // Disable prev button if we don't have any older data
            const oldestDate = new Date(Math.min(...drifts.map(d => new Date(d.date))));
            const now = new Date();
            const periodSize = 180 * 24 * 60 * 60 * 1000; // ~6 months in milliseconds

            const currentPeriodStart = new Date(now - (driftsOffset + 1) * periodSize);
            prevBtn.disabled = oldestDate > currentPeriodStart;
        }

        // Add event listeners for drifts navigation buttons
        document.getElementById('driftsPrevPeriod').addEventListener('click', () => {
            driftsOffset++;
            const data = processDriftsData(allDrifts, 'daily');
            updateDriftsChart(data);
        });

        document.getElementById('driftsNextPeriod').addEventListener('click', () => {
            driftsOffset--;
            const data = processDriftsData(allDrifts, 'daily');
            updateDriftsChart(data);
        });

        // Initialize dashboard
        async function initDashboard() {
            try {
                // Fetch and display today's tasks first
                await fetchTodaysTasks();
                
                // Initialize task performance chart
                await fetchTaskPerformance(1);

                // Fetch all data
                const journals = await fetchJournalStats();
                const observations = await fetchObservationStats();
                const drifts = await fetchDriftStats();
                
                // Initialize activity charts
                const journalData = processJournalData(journals, 'monthly');
                updateChart(journalData, 'monthly');

                // Initialize distribution chart
                updateDistributionChart(journals);

                // Initialize observations chart
                const observationsData = processObservationsData(observations, 'monthly');
                updateObservationsChart(observationsData);

                // Initialize drifts charts
                const driftsData = processDriftsData(drifts, 'monthly');
                updateDriftsChart(driftsData);

                const driftPatternsData = processDriftPatternsData();
                updateDriftPatternsCharts(driftPatternsData);

                // Initialize tag charts with default range (last 7 days)
                updateTagCharts(observations, 'week');

                // Add event listeners for observation tag time range buttons
                document.querySelectorAll('.time-range-btn[data-target="observation-tags"]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Update active button
                        document.querySelectorAll('.time-range-btn[data-target="observation-tags"]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        const range = btn.dataset.range;
                        currentTagRange = range;
                        updateTagCharts(observations, range);
                    });
                });

                // Add event listeners for drift tag time range buttons
                document.querySelectorAll('.time-range-btn[data-target="drift-tags"]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Update active button
                        document.querySelectorAll('.time-range-btn[data-target="drift-tags"]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        const range = btn.dataset.range;
                        const driftPatternsData = processDriftPatternsData(range);
                        updateDriftPatternsCharts(driftPatternsData);
                    });
                });

                // Add event listeners for tag time range buttons
                document.querySelectorAll('.time-range-btn[data-target="tags"]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        // Update active button
                        document.querySelectorAll('.time-range-btn[data-target="tags"]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');

                        const range = btn.dataset.range;
                        currentTagRange = range;
                        updateTagCharts(allObservations, range);
                    });
                });

                // Add event listeners for task performance navigation
                document.getElementById('taskPrevPeriod').addEventListener('click', () => {
                    currentPage++;
                    fetchTaskPerformance(currentPage);
                });

                document.getElementById('taskNextPeriod').addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        fetchTaskPerformance(currentPage);
                    }
                });

                // Add event listeners for journal navigation buttons
                document.getElementById('prevPeriod').addEventListener('click', () => {
                    currentOffset++;
                    const data = processJournalData(allJournals, 'monthly');
                    updateChart(data, 'monthly');
                });

                document.getElementById('nextPeriod').addEventListener('click', () => {
                    currentOffset--;
                    const data = processJournalData(allJournals, 'monthly');
                    updateChart(data, 'monthly');
                });

                // Add event listeners for observations navigation buttons
                document.getElementById('observationsPrevPeriod').addEventListener('click', () => {
                    observationsOffset++;
                    const data = processObservationsData(allObservations, 'monthly');
                    updateObservationsChart(data);
                });

                document.getElementById('observationsNextPeriod').addEventListener('click', () => {
                    observationsOffset--;
                    const data = processObservationsData(allObservations, 'monthly');
                    updateObservationsChart(data);
                });
            } catch (error) {
                console.error('Error initializing dashboard:', error);
            }
        }

        // Start the dashboard
        document.addEventListener('DOMContentLoaded', () => {
            initDashboard();
        });

        async function fetchTodaysTasks() {
            try {
                // First fetch all todos with pagination
                const allTodos = await fetchAllTodos();
                
                // Then apply filtering logic to the complete dataset
                const dueTasks = allTodos.filter(todo => {
                    if (todo.type === 'onetime') {
                        return !todo.completed || todo.completed.length === 0;
                    }


                    const latestCompletion = todo.completed && todo.completed.length > 0 
                        ? new Date(Math.max(...todo.completed.map(date => new Date(date))))
                        : null;

                    if (!latestCompletion) return true;

                    const now = new Date();
                    const dueDate = new Date(latestCompletion);

                    switch (todo.every.unit) {
                        case 'day':
                            dueDate.setDate(dueDate.getDate() + todo.every.amount);
                            break;
                        case 'week':
                            dueDate.setDate(dueDate.getDate() + (todo.every.amount * 7));
                            break;
                        case 'month':
                            dueDate.setMonth(dueDate.getMonth() + todo.every.amount);
                            break;
                    }

                    return now >= dueDate;
                });

                const tasksList = document.getElementById('tasksList');
                const tasksCount = document.getElementById('tasksCount');
                
                tasksCount.textContent = `${dueTasks.length} task${dueTasks.length !== 1 ? 's' : ''}`;

                if (dueTasks.length === 0) {
                    tasksList.innerHTML = '<div class="task-item"><div class="task-info"><div class="task-title">No tasks due today</div></div></div>';
                    return;
                }

                tasksList.innerHTML = dueTasks.map(todo => `
                    <div class="task-item">
                        <div class="task-info">
                            <div class="task-title">${todo.work}</div>
                            <div class="task-meta">
                                <span class="task-type">${todo.type}</span>
                                ${todo.every ? `<span class="task-schedule">Every ${todo.every.amount} ${todo.every.unit}${todo.every.amount > 1 ? 's' : ''}</span>` : ''}
                            </div>
                        </div>
                        <div class="task-actions">
                            <button class="complete-btn" onclick="completeTodo('${todo._id}')">Complete</button>
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error fetching today\'s tasks:', error);
                const tasksList = document.getElementById('tasksList');
                tasksList.innerHTML = '<div class="task-item"><div class="task-info"><div class="task-title">Error loading tasks</div></div></div>';
            }
        }

        async function fetchAllTodos() {
            try {
                // Get first page to determine total number of todos
                const response1 = await fetch(`/api/todo?filters=${JSON.stringify({})}&limit=200&page=1`);
                const data1 = await response1.json();
                
                if (!response1.ok) {
                    throw new Error('Failed to fetch todos');
                }

                const totalTodos = data1.data.total;
                let allTodos = [...data1.data.todos];

                // Calculate how many more pages we need to fetch
                const totalPages = Math.ceil(totalTodos / 200);

                if (totalPages > 1) {
                    // Create an array of promises for the remaining pages
                    const remainingRequests = Array.from({ length: totalPages - 1 }, (_, i) => 
                        fetch(`/api/todo?filters=${JSON.stringify({})}&limit=200&page=${i + 2}`)
                            .then(res => res.json())
                            .then(data => data.data.todos)
                    );

                    // Fetch all remaining pages in parallel
                    const remainingTodos = await Promise.all(remainingRequests);
                    allTodos = [...allTodos, ...remainingTodos.flat()];
                }

                return allTodos;
            } catch (error) {
                console.error('Error fetching todos:', error);
                return [];
            }
        }

        async function fetchTaskPerformance(page = 1) {
            try {
                const endDate = new Date();
                endDate.setDate(endDate.getDate() - (page - 1) * DAYS_PER_PAGE);
                const startDate = new Date(endDate);
                startDate.setDate(startDate.getDate() - (DAYS_PER_PAGE - 1));

                // Format dates for display
                const formatDate = date => date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                document.getElementById('taskCurrentPeriod').textContent = 
                    `${formatDate(startDate)} - ${formatDate(endDate)}`;

                // Fetch all todos first
                const allTodos = await fetchAllTodos();

                // Prepare data for the chart
                const dates = Array.from({length: DAYS_PER_PAGE}, (_, i) => {
                    const date = new Date(startDate);
                    date.setDate(date.getDate() + i);
                    return date;
                });

                // Process the complete dataset
                const performanceData = dates.map(date => {
                    const dateStr = date.toISOString().split('T')[0];
                    const dateStart = new Date(date);
                    dateStart.setHours(0, 0, 0, 0);
                    const dateEnd = new Date(date);
                    dateEnd.setHours(23, 59, 59, 999);

                    // Calculate completed tasks for this date
                    const completedTasks = allTodos.filter(todo => {
                        if (!todo.completed || todo.completed.length === 0) return false;
                        return todo.completed.some(completionDate => {
                            const completed = new Date(completionDate);
                            return completed >= dateStart && completed <= dateEnd;
                        });
                    }).length;

                    // Calculate expected tasks for this date
                    const expectedTasks = allTodos.filter(todo => {
                        if (todo.type === 'onetime') {

                            if (todo.completed && todo.completed.length === 0) {
                                return new Date(todo.createdAt) <= dateEnd;


                            } else if (todo.completed && todo.completed.length > 0) {
                                // console.log("completed: "+ todo.completed);
                                // console.log("dateEnd: "+ dateEnd);
                                // console.log("createdAt: "+ todo.createdAt);
                                return new Date(todo.createdAt) <= dateEnd && new Date(todo.completed[0]) >= dateStart;
                             }


                            // console.log("createdAt: "+ todo.createdAt);
                            // console.log("dateEnd: "+ dateEnd); 
                            
                        }

                        // If the task has no completions (recurring), it's expected, it sh
                        if (todo.completed?.length === 0 && new Date(todo.createdAt) <= dateEnd) {
                            return true;
                        }


                        // If it has completions, sort them by date
                        const sortedCompletions = todo.completed.sort((a, b) => new Date(a) - new Date(b));
                        // console.log("SortedCompletions: "+ sortedCompletions);

                        for (let i = 0; i < sortedCompletions.length; i++) {
                            const completion = sortedCompletions[i];
                            if (new Date(todo.createdAt) >= dateEnd) {
                                return false;
                            }

                            // console.log("Completion: "+ new Date(completion) + "\n", "DateStart: "+ dateStart + "\n", "DateEnd: "+ dateEnd+ "\n", "CreatedAt: "+ new Date(todo.createdAt));
                            // console.log("Completion: "+ new Date(completion) + "\n", "DateStart: "+ dateStart + "\n", "DateEnd: "+ dateEnd+ "\n", "CreatedAt: "+ new Date(todo.createdAt));
                            // console.log(i)
                            
                            if(new Date(completion) >= dateStart && i === 0) {
                                return true;
                            } else if (new Date(completion) <= dateStart && sortedCompletions.length === 1) {
                                

                                // calculate the next due date
                                const nextDueDate = new Date(completion);
                                switch (todo.every.unit) {
                                    case 'day':
                                        nextDueDate.setDate(nextDueDate.getDate() + todo.every.amount);
                                        break;
                                    case 'week':
                                        nextDueDate.setDate(nextDueDate.getDate() + (todo.every.amount * 7));
                                        break;
                                    case 'month':
                                        nextDueDate.setMonth(nextDueDate.getMonth() + todo.every.amount);
                                        break;
                                } 

                                if (nextDueDate <= dateEnd) {
                                    return true;
                                }
                            }
                            

                            if (i != 0 && dateStart <= new Date(completion)) {
                                const previousCompletion = sortedCompletions[i-1];
                                const nextDueDate = new Date(previousCompletion);

                                switch (todo.every.unit) {
                                    case 'day':
                                        nextDueDate.setDate(nextDueDate.getDate() + todo.every.amount);
                                        break;
                                    case 'week':
                                        nextDueDate.setDate(nextDueDate.getDate() + (todo.every.amount * 7));
                                        break;
                                    case 'month':
                                        nextDueDate.setMonth(nextDueDate.getMonth() + todo.every.amount);
                                        break;
                                }
                                // console.log("NextDueDate: "+ nextDueDate);

                                if (nextDueDate <= dateEnd) {
                                    return true;
                                }
                            }


                            
                        }
                    }).length;


                    return {
                        date: dateStr,
                        completed: completedTasks,
                        total: expectedTasks,
                        percentage: expectedTasks > 0 ? Math.round((completedTasks / expectedTasks) * 100) : 0
                    };
                });

                // Update the chart with the processed data
                await updatePerformanceChart(performanceData);
            } catch (error) {
                console.error('Error fetching task performance:', error);
                document.getElementById('taskPerformanceChart').innerHTML = '<div class="error">Error loading performance data</div>';
            }
        }

        async function updatePerformanceChart(performanceData) {
            const ctx = document.getElementById('taskPerformanceChart').getContext('2d');
            
            if (performanceChart) {
                performanceChart.destroy();
            }

            performanceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: performanceData.map(d => new Date(d.date).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })),
                    datasets: [
                        {
                            label: 'Expected',
                            data: performanceData.map(d => d.total),
                            backgroundColor: '#3b82f6',
                            borderColor: '#3b82f6',
                            borderWidth: 0,
                            borderRadius: 4,
                            order: 2
                        },
                        {
                            label: 'Completed',
                            data: performanceData.map(d => d.completed),
                            backgroundColor: '#22c55e',
                            borderColor: '#22c55e',
                            borderWidth: 0,
                            borderRadius: 4,
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: (items) => {
                                    const date = new Date(performanceData[items[0].dataIndex].date);
                                    return date.toLocaleDateString('en-US', { 
                                        weekday: 'long',
                                        year: 'numeric',
                                        month: 'long',
                                        day: 'numeric'
                                    });
                                },
                                label: (context) => {
                                    const label = context.dataset.label;
                                    const value = context.raw;
                                    const data = performanceData[context.dataIndex];
                                    if (label === 'Completed') {
                                        return `${label}: ${value} (${data.percentage}%)`;
                                    }
                                    return `${label}: ${value}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: '#94a3b8'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: '#334155'
                            },
                            ticks: {
                                color: '#94a3b8',
                                stepSize: 1,
                                precision: 0
                            }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
